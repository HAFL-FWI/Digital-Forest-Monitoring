"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _asserts = require("../asserts.js");

var _extent = require("../extent.js");

var _Feature2 = require("./Feature.js");

var _JSONFeature = _interopRequireDefault(require("./JSONFeature.js"));

var _GeometryLayout = _interopRequireDefault(require("../geom/GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _LineString = _interopRequireDefault(require("../geom/LineString.js"));

var _LinearRing = _interopRequireDefault(require("../geom/LinearRing.js"));

var _MultiLineString = _interopRequireDefault(require("../geom/MultiLineString.js"));

var _MultiPoint = _interopRequireDefault(require("../geom/MultiPoint.js"));

var _MultiPolygon = _interopRequireDefault(require("../geom/MultiPolygon.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Polygon = _interopRequireDefault(require("../geom/Polygon.js"));

var _deflate = require("../geom/flat/deflate.js");

var _orient = require("../geom/flat/orient.js");

var _obj = require("../obj.js");

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/format/EsriJSON
 */


/**
 * @typedef {import("arcgis-rest-api").Feature} EsriJSONFeature
 * @typedef {import("arcgis-rest-api").FeatureSet} EsriJSONFeatureSet
 * @typedef {import("arcgis-rest-api").Geometry} EsriJSONGeometry
 * @typedef {import("arcgis-rest-api").Point} EsriJSONPoint
 * @typedef {import("arcgis-rest-api").Polyline} EsriJSONPolyline
 * @typedef {import("arcgis-rest-api").Polygon} EsriJSONPolygon
 * @typedef {import("arcgis-rest-api").Multipoint} EsriJSONMultipoint
 * @typedef {import("arcgis-rest-api").HasZM} EsriJSONHasZM
 * @typedef {import("arcgis-rest-api").Position} EsriJSONPosition
 * @typedef {import("arcgis-rest-api").SpatialReferenceWkid} EsriJSONSpatialReferenceWkid
 */

/**
 * @typedef {Object} EsriJSONMultiPolygon
 * @property {Array<Array<Array<Array<number>>>>} rings Rings for the MultiPolygon.
 * @property {boolean} [hasM] If the polygon coordinates have an M value.
 * @property {boolean} [hasZ] If the polygon coordinates have a Z value.
 * @property {EsriJSONSpatialReferenceWkid} [spatialReference] The coordinate reference system.
 */

/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default, function(EsriJSONGeometry): import("../geom/Geometry.js").default>}
 */
var GEOMETRY_READERS = {};
GEOMETRY_READERS[_GeometryType.default.POINT] = readPointGeometry;
GEOMETRY_READERS[_GeometryType.default.LINE_STRING] = readLineStringGeometry;
GEOMETRY_READERS[_GeometryType.default.POLYGON] = readPolygonGeometry;
GEOMETRY_READERS[_GeometryType.default.MULTI_POINT] = readMultiPointGeometry;
GEOMETRY_READERS[_GeometryType.default.MULTI_LINE_STRING] = readMultiLineStringGeometry;
GEOMETRY_READERS[_GeometryType.default.MULTI_POLYGON] = readMultiPolygonGeometry;
/**
 * @const
 * @type {Object<string, function(import("../geom/Geometry.js").default, import("./Feature.js").WriteOptions=): (EsriJSONGeometry)>}
 */

var GEOMETRY_WRITERS = {};
GEOMETRY_WRITERS[_GeometryType.default.POINT] = writePointGeometry;
GEOMETRY_WRITERS[_GeometryType.default.LINE_STRING] = writeLineStringGeometry;
GEOMETRY_WRITERS[_GeometryType.default.POLYGON] = writePolygonGeometry;
GEOMETRY_WRITERS[_GeometryType.default.MULTI_POINT] = writeMultiPointGeometry;
GEOMETRY_WRITERS[_GeometryType.default.MULTI_LINE_STRING] = writeMultiLineStringGeometry;
GEOMETRY_WRITERS[_GeometryType.default.MULTI_POLYGON] = writeMultiPolygonGeometry;
/**
 * @typedef {Object} Options
 * @property {string} [geometryName] Geometry name to use when creating features.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the EsriJSON format.
 *
 * @api
 */

var EsriJSON =
/** @class */
function (_super) {
  __extends(EsriJSON, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function EsriJSON(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */

    _this.geometryName_ = options.geometryName;
    return _this;
  }
  /**
   * @inheritDoc
   */


  EsriJSON.prototype.readFeatureFromObject = function (object, opt_options) {
    var esriJSONFeature =
    /** @type {EsriJSONFeature} */
    object;
    var geometry = readGeometry(esriJSONFeature.geometry, opt_options);
    var feature = new _Feature.default();

    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    }

    feature.setGeometry(geometry);

    if (opt_options && opt_options.idField && esriJSONFeature.attributes[opt_options.idField]) {
      feature.setId(
      /** @type {number} */
      esriJSONFeature.attributes[opt_options.idField]);
    }

    if (esriJSONFeature.attributes) {
      feature.setProperties(esriJSONFeature.attributes, true);
    }

    return feature;
  };
  /**
   * @inheritDoc
   */


  EsriJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
    var options = opt_options ? opt_options : {};

    if (object['features']) {
      var esriJSONFeatureSet =
      /** @type {EsriJSONFeatureSet} */
      object;
      /** @type {Array<import("../Feature.js").default>} */

      var features = [];
      var esriJSONFeatures = esriJSONFeatureSet.features;
      options.idField = object.objectIdFieldName;

      for (var i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(esriJSONFeatures[i], options));
      }

      return features;
    } else {
      return [this.readFeatureFromObject(object, options)];
    }
  };
  /**
   * @inheritDoc
   */


  EsriJSON.prototype.readGeometryFromObject = function (object, opt_options) {
    return readGeometry(
    /** @type {EsriJSONGeometry} */
    object, opt_options);
  };
  /**
   * @inheritDoc
   */


  EsriJSON.prototype.readProjectionFromObject = function (object) {
    if (object['spatialReference'] && object['spatialReference']['wkid'] !== undefined) {
      var spatialReference =
      /** @type {EsriJSONSpatialReferenceWkid} */
      object['spatialReference'];
      var crs = spatialReference.wkid;
      return (0, _proj.get)('EPSG:' + crs);
    } else {
      return null;
    }
  };
  /**
   * Encode a geometry as a EsriJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {EsriJSONGeometry} Object.
   * @override
   * @api
   */


  EsriJSON.prototype.writeGeometryObject = function (geometry, opt_options) {
    return writeGeometry(geometry, this.adaptOptions(opt_options));
  };
  /**
   * Encode a feature as a esriJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {Object} Object.
   * @override
   * @api
   */


  EsriJSON.prototype.writeFeatureObject = function (feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var object = {};
    var geometry = feature.getGeometry();

    if (geometry) {
      object['geometry'] = writeGeometry(geometry, opt_options);

      if (opt_options && opt_options.featureProjection) {
        object['geometry']['spatialReference'] =
        /** @type {EsriJSONSpatialReferenceWkid} */
        {
          wkid: Number((0, _proj.get)(opt_options.featureProjection).getCode().split(':').pop())
        };
      }
    }

    var properties = feature.getProperties();
    delete properties[feature.getGeometryName()];

    if (!(0, _obj.isEmpty)(properties)) {
      object['attributes'] = properties;
    } else {
      object['attributes'] = {};
    }

    return object;
  };
  /**
   * Encode an array of features as a EsriJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {EsriJSONFeatureSet} EsriJSON Object.
   * @override
   * @api
   */


  EsriJSON.prototype.writeFeaturesObject = function (features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];

    for (var i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], opt_options));
    }

    return {
      'features': objects
    };
  };

  return EsriJSON;
}(_JSONFeature.default);
/**
 * @param {EsriJSONGeometry} object Object.
 * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */


function readGeometry(object, opt_options) {
  var _a, _b;

  if (!object) {
    return null;
  }
  /** @type {import("../geom/GeometryType.js").default} */


  var type;

  if (typeof object['x'] === 'number' && typeof object['y'] === 'number') {
    type = _GeometryType.default.POINT;
  } else if (object['points']) {
    type = _GeometryType.default.MULTI_POINT;
  } else if (object['paths']) {
    var esriJSONPolyline =
    /** @type {EsriJSONPolyline} */
    object;

    if (esriJSONPolyline.paths.length === 1) {
      type = _GeometryType.default.LINE_STRING;
    } else {
      type = _GeometryType.default.MULTI_LINE_STRING;
    }
  } else if (object['rings']) {
    var esriJSONPolygon =
    /** @type {EsriJSONPolygon} */
    object;
    var layout = getGeometryLayout(esriJSONPolygon);
    var rings = convertRings(esriJSONPolygon.rings, layout);

    if (rings.length === 1) {
      type = _GeometryType.default.POLYGON;
      object = Object.assign({}, object, (_a = {}, _a['rings'] = rings[0], _a));
    } else {
      type = _GeometryType.default.MULTI_POLYGON;
      object = Object.assign({}, object, (_b = {}, _b['rings'] = rings, _b));
    }
  }

  var geometryReader = GEOMETRY_READERS[type];
  return (0, _Feature2.transformGeometryWithOptions)(geometryReader(object), false, opt_options);
}
/**
 * Determines inner and outer rings.
 * Checks if any polygons in this array contain any other polygons in this
 * array. It is used for checking for holes.
 * Logic inspired by: https://github.com/Esri/terraformer-arcgis-parser
 * @param {Array<!Array<!Array<number>>>} rings Rings.
 * @param {import("../geom/GeometryLayout.js").default} layout Geometry layout.
 * @return {Array<!Array<!Array<!Array<number>>>>} Transformed rings.
 */


function convertRings(rings, layout) {
  var flatRing = [];
  var outerRings = [];
  var holes = [];
  var i, ii;

  for (i = 0, ii = rings.length; i < ii; ++i) {
    flatRing.length = 0;
    (0, _deflate.deflateCoordinates)(flatRing, 0, rings[i], layout.length); // is this ring an outer ring? is it clockwise?

    var clockwise = (0, _orient.linearRingIsClockwise)(flatRing, 0, flatRing.length, layout.length);

    if (clockwise) {
      outerRings.push([rings[i]]);
    } else {
      holes.push(rings[i]);
    }
  }

  while (holes.length) {
    var hole = holes.shift();
    var matched = false; // loop over all outer rings and see if they contain our hole.

    for (i = outerRings.length - 1; i >= 0; i--) {
      var outerRing = outerRings[i][0];
      var containsHole = (0, _extent.containsExtent)(new _LinearRing.default(outerRing).getExtent(), new _LinearRing.default(hole).getExtent());

      if (containsHole) {
        // the hole is contained push it into our polygon
        outerRings[i].push(hole);
        matched = true;
        break;
      }
    }

    if (!matched) {
      // no outer rings contain this hole turn it into and outer
      // ring (reverse it)
      outerRings.push([hole.reverse()]);
    }
  }

  return outerRings;
}
/**
 * @param {EsriJSONPoint} object Object.
 * @return {import("../geom/Geometry.js").default} Point.
 */


function readPointGeometry(object) {
  var point;

  if (object.m !== undefined && object.z !== undefined) {
    point = new _Point.default([object.x, object.y, object.z, object.m], _GeometryLayout.default.XYZM);
  } else if (object.z !== undefined) {
    point = new _Point.default([object.x, object.y, object.z], _GeometryLayout.default.XYZ);
  } else if (object.m !== undefined) {
    point = new _Point.default([object.x, object.y, object.m], _GeometryLayout.default.XYM);
  } else {
    point = new _Point.default([object.x, object.y]);
  }

  return point;
}
/**
 * @param {EsriJSONPolyline} object Object.
 * @return {import("../geom/Geometry.js").default} LineString.
 */


function readLineStringGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _LineString.default(object.paths[0], layout);
}
/**
 * @param {EsriJSONPolyline} object Object.
 * @return {import("../geom/Geometry.js").default} MultiLineString.
 */


function readMultiLineStringGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _MultiLineString.default(object.paths, layout);
}
/**
 * @param {EsriJSONHasZM} object Object.
 * @return {import("../geom/GeometryLayout.js").default} The geometry layout to use.
 */


function getGeometryLayout(object) {
  var layout = _GeometryLayout.default.XY;

  if (object.hasZ === true && object.hasM === true) {
    layout = _GeometryLayout.default.XYZM;
  } else if (object.hasZ === true) {
    layout = _GeometryLayout.default.XYZ;
  } else if (object.hasM === true) {
    layout = _GeometryLayout.default.XYM;
  }

  return layout;
}
/**
 * @param {EsriJSONMultipoint} object Object.
 * @return {import("../geom/Geometry.js").default} MultiPoint.
 */


function readMultiPointGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _MultiPoint.default(object.points, layout);
}
/**
 * @param {EsriJSONMultiPolygon} object Object.
 * @return {import("../geom/Geometry.js").default} MultiPolygon.
 */


function readMultiPolygonGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _MultiPolygon.default(object.rings, layout);
}
/**
 * @param {EsriJSONPolygon} object Object.
 * @return {import("../geom/Geometry.js").default} Polygon.
 */


function readPolygonGeometry(object) {
  var layout = getGeometryLayout(object);
  return new _Polygon.default(object.rings, layout);
}
/**
 * @param {import("../geom/Point.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {EsriJSONPoint} EsriJSON geometry.
 */


function writePointGeometry(geometry, opt_options) {
  var coordinates = geometry.getCoordinates();
  /** @type {EsriJSONPoint} */

  var esriJSON;
  var layout = geometry.getLayout();

  if (layout === _GeometryLayout.default.XYZ) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      z: coordinates[2]
    };
  } else if (layout === _GeometryLayout.default.XYM) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      m: coordinates[2]
    };
  } else if (layout === _GeometryLayout.default.XYZM) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      z: coordinates[2],
      m: coordinates[3]
    };
  } else if (layout === _GeometryLayout.default.XY) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1]
    };
  } else {
    (0, _asserts.assert)(false, 34); // Invalid geometry layout
  }

  return esriJSON;
}
/**
 * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @return {Object} Object with boolean hasZ and hasM keys.
 */


function getHasZM(geometry) {
  var layout = geometry.getLayout();
  return {
    hasZ: layout === _GeometryLayout.default.XYZ || layout === _GeometryLayout.default.XYZM,
    hasM: layout === _GeometryLayout.default.XYM || layout === _GeometryLayout.default.XYZM
  };
}
/**
 * @param {import("../geom/LineString.js").default} lineString Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {EsriJSONPolyline} EsriJSON geometry.
 */


function writeLineStringGeometry(lineString, opt_options) {
  var hasZM = getHasZM(lineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: [
    /** @type {Array<EsriJSONPosition>} */
    lineString.getCoordinates()]
  };
}
/**
 * @param {import("../geom/Polygon.js").default} polygon Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {EsriJSONPolygon} EsriJSON geometry.
 */


function writePolygonGeometry(polygon, opt_options) {
  // Esri geometries use the left-hand rule
  var hasZM = getHasZM(polygon);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings:
    /** @type {Array<Array<EsriJSONPosition>>} */
    polygon.getCoordinates(false)
  };
}
/**
 * @param {import("../geom/MultiLineString.js").default} multiLineString Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {EsriJSONPolyline} EsriJSON geometry.
 */


function writeMultiLineStringGeometry(multiLineString, opt_options) {
  var hasZM = getHasZM(multiLineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths:
    /** @type {Array<Array<EsriJSONPosition>>} */
    multiLineString.getCoordinates()
  };
}
/**
 * @param {import("../geom/MultiPoint.js").default} multiPoint Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {EsriJSONMultipoint} EsriJSON geometry.
 */


function writeMultiPointGeometry(multiPoint, opt_options) {
  var hasZM = getHasZM(multiPoint);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    points:
    /** @type {Array<EsriJSONPosition>} */
    multiPoint.getCoordinates()
  };
}
/**
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {EsriJSONPolygon} EsriJSON geometry.
 */


function writeMultiPolygonGeometry(geometry, opt_options) {
  var hasZM = getHasZM(geometry);
  var coordinates = geometry.getCoordinates(false);
  var output = [];

  for (var i = 0; i < coordinates.length; i++) {
    for (var x = coordinates[i].length - 1; x >= 0; x--) {
      output.push(coordinates[i][x]);
    }
  }

  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings:
    /** @type {Array<Array<EsriJSONPosition>>} */
    output
  };
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {EsriJSONGeometry} EsriJSON geometry.
 */


function writeGeometry(geometry, opt_options) {
  var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];
  return geometryWriter((0, _Feature2.transformGeometryWithOptions)(geometry, true, opt_options), opt_options);
}

var _default = EsriJSON;
exports.default = _default;