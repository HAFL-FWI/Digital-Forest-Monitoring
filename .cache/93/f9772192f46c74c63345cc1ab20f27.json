{"id":"../node_modules/ol/geom/flat/geodesic.js","dependencies":[{"name":"/Users/hk/Sites/digital-forest-monitoring/package.json","includedInParent":true,"mtime":1574333047455},{"name":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/package.json","includedInParent":true,"mtime":1573122283680},{"name":"../../math.js","loc":{"line":4,"column":61},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/flat/geodesic.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/math.js"},{"name":"../../proj.js","loc":{"line":5,"column":51},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/flat/geodesic.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/proj.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.greatCircleArc = greatCircleArc;\nexports.meridian = meridian;\nexports.parallel = parallel;\n\nvar _math = require(\"../../math.js\");\n\nvar _proj = require(\"../../proj.js\");\n\n/**\n * @module ol/geom/flat/geodesic\n */\n\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n\n  /** @type {Array<number>} */\n  var flatCoordinates = [];\n  var geoA = interpolate(0);\n  var geoB = interpolate(1);\n  var a = transform(geoA);\n  var b = transform(geoB);\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n\n  var geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n\n  var stack = [b, a];\n  /** @type {Array<number>} */\n\n  var fractionStack = [1, 0];\n  /** @type {!Object<string, boolean>} */\n\n  var fractions = {};\n  var maxIterations = 1e5;\n  var geoM, m, fracA, fracB, fracM, key;\n\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop(); // Add the a coordinate if it has not been added yet\n\n    key = fracA.toString();\n\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    } // Pop the b coordinate off the stack\n\n\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop(); // Find the m point between the a and b coordinates\n\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n\n    if ((0, _math.squaredSegmentDistance)(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n\n  return flatCoordinates;\n}\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\n\nfunction greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n  var geoProjection = (0, _proj.get)('EPSG:4326');\n  var cosLat1 = Math.cos((0, _math.toRadians)(lat1));\n  var sinLat1 = Math.sin((0, _math.toRadians)(lat1));\n  var cosLat2 = Math.cos((0, _math.toRadians)(lat2));\n  var sinLat2 = Math.sin((0, _math.toRadians)(lat2));\n  var cosDeltaLon = Math.cos((0, _math.toRadians)(lon2 - lon1));\n  var sinDeltaLon = Math.sin((0, _math.toRadians)(lon2 - lon1));\n  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    if (1 <= d) {\n      return [lon2, lat2];\n    }\n\n    var D = frac * Math.acos(d);\n    var cosD = Math.cos(D);\n    var sinD = Math.sin(D);\n    var y = sinDeltaLon * cosLat2;\n    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n    var theta = Math.atan2(y, x);\n    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n    var lon = (0, _math.toRadians)(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));\n    return [(0, _math.toDegrees)(lon), (0, _math.toDegrees)(lat)];\n  }, (0, _proj.getTransform)(geoProjection, projection), squaredTolerance);\n}\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\n\nfunction meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  var epsg4326Projection = (0, _proj.get)('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon, lat1 + (lat2 - lat1) * frac];\n  }, (0, _proj.getTransform)(epsg4326Projection, projection), squaredTolerance);\n}\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\n\nfunction parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  var epsg4326Projection = (0, _proj.get)('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon1 + (lon2 - lon1) * frac, lat];\n  }, (0, _proj.getTransform)(epsg4326Projection, projection), squaredTolerance);\n}"},"sourceMaps":null,"error":null,"hash":"a59791609571b3769d4c19517a9e8d53","cacheData":{"env":{}}}