{"id":"../node_modules/@material/slider/foundation.js","dependencies":[{"name":"/Users/hk/Sites/digital-forest-monitoring/package.json","includedInParent":true,"mtime":1574333047455},{"name":"/Users/hk/Sites/digital-forest-monitoring/node_modules/@material/slider/package.json","includedInParent":true,"mtime":1573206123654},{"name":"tslib","loc":{"line":23,"column":25},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/@material/slider/foundation.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/tslib/tslib.es6.js"},{"name":"@material/animation/util","loc":{"line":24,"column":60},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/@material/slider/foundation.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/@material/animation/util.js"},{"name":"@material/base/foundation","loc":{"line":25,"column":30},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/@material/slider/foundation.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/@material/base/foundation.js"},{"name":"./constants","loc":{"line":26,"column":45},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/@material/slider/foundation.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/@material/slider/constants.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.MDCSliderFoundation = void 0;\n\nvar tslib_1 = _interopRequireWildcard(require(\"tslib\"));\n\nvar _util = require(\"@material/animation/util\");\n\nvar _foundation = require(\"@material/base/foundation\");\n\nvar _constants = require(\"./constants\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];\nvar UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];\nvar MOVE_EVENT_MAP = {\n  mousedown: 'mousemove',\n  pointerdown: 'pointermove',\n  touchstart: 'touchmove'\n};\nvar KEY_IDS = {\n  ARROW_DOWN: 'ArrowDown',\n  ARROW_LEFT: 'ArrowLeft',\n  ARROW_RIGHT: 'ArrowRight',\n  ARROW_UP: 'ArrowUp',\n  END: 'End',\n  HOME: 'Home',\n  PAGE_DOWN: 'PageDown',\n  PAGE_UP: 'PageUp'\n};\n\nvar MDCSliderFoundation =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MDCSliderFoundation, _super);\n\n  function MDCSliderFoundation(adapter) {\n    var _this = _super.call(this, tslib_1.__assign({}, MDCSliderFoundation.defaultAdapter, adapter)) || this;\n    /**\n     * We set this to NaN since we want it to be a number, but we can't use '0' or '-1'\n     * because those could be valid tabindices set by the client code.\n     */\n\n\n    _this.savedTabIndex_ = NaN;\n    _this.active_ = false;\n    _this.inTransit_ = false;\n    _this.isDiscrete_ = false;\n    _this.hasTrackMarker_ = false;\n    _this.handlingThumbTargetEvt_ = false;\n    _this.min_ = 0;\n    _this.max_ = 100;\n    _this.step_ = 0;\n    _this.value_ = 0;\n    _this.disabled_ = false;\n    _this.preventFocusState_ = false;\n\n    _this.thumbContainerPointerHandler_ = function () {\n      return _this.handlingThumbTargetEvt_ = true;\n    };\n\n    _this.interactionStartHandler_ = function (evt) {\n      return _this.handleDown_(evt);\n    };\n\n    _this.keydownHandler_ = function (evt) {\n      return _this.handleKeydown_(evt);\n    };\n\n    _this.focusHandler_ = function () {\n      return _this.handleFocus_();\n    };\n\n    _this.blurHandler_ = function () {\n      return _this.handleBlur_();\n    };\n\n    _this.resizeHandler_ = function () {\n      return _this.layout();\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(MDCSliderFoundation, \"cssClasses\", {\n    get: function () {\n      return _constants.cssClasses;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCSliderFoundation, \"strings\", {\n    get: function () {\n      return _constants.strings;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCSliderFoundation, \"numbers\", {\n    get: function () {\n      return _constants.numbers;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCSliderFoundation, \"defaultAdapter\", {\n    get: function () {\n      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n      return {\n        hasClass: function () {\n          return false;\n        },\n        addClass: function () {\n          return undefined;\n        },\n        removeClass: function () {\n          return undefined;\n        },\n        getAttribute: function () {\n          return null;\n        },\n        setAttribute: function () {\n          return undefined;\n        },\n        removeAttribute: function () {\n          return undefined;\n        },\n        computeBoundingRect: function () {\n          return {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            width: 0,\n            height: 0\n          };\n        },\n        getTabIndex: function () {\n          return 0;\n        },\n        registerInteractionHandler: function () {\n          return undefined;\n        },\n        deregisterInteractionHandler: function () {\n          return undefined;\n        },\n        registerThumbContainerInteractionHandler: function () {\n          return undefined;\n        },\n        deregisterThumbContainerInteractionHandler: function () {\n          return undefined;\n        },\n        registerBodyInteractionHandler: function () {\n          return undefined;\n        },\n        deregisterBodyInteractionHandler: function () {\n          return undefined;\n        },\n        registerResizeHandler: function () {\n          return undefined;\n        },\n        deregisterResizeHandler: function () {\n          return undefined;\n        },\n        notifyInput: function () {\n          return undefined;\n        },\n        notifyChange: function () {\n          return undefined;\n        },\n        setThumbContainerStyleProperty: function () {\n          return undefined;\n        },\n        setTrackStyleProperty: function () {\n          return undefined;\n        },\n        setMarkerValue: function () {\n          return undefined;\n        },\n        setTrackMarkers: function () {\n          return undefined;\n        },\n        isRTL: function () {\n          return false;\n        }\n      }; // tslint:enable:object-literal-sort-keys\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MDCSliderFoundation.prototype.init = function () {\n    var _this = this;\n\n    this.isDiscrete_ = this.adapter_.hasClass(_constants.cssClasses.IS_DISCRETE);\n    this.hasTrackMarker_ = this.adapter_.hasClass(_constants.cssClasses.HAS_TRACK_MARKER);\n    DOWN_EVENTS.forEach(function (evtName) {\n      _this.adapter_.registerInteractionHandler(evtName, _this.interactionStartHandler_);\n\n      _this.adapter_.registerThumbContainerInteractionHandler(evtName, _this.thumbContainerPointerHandler_);\n    });\n    this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);\n    this.adapter_.registerInteractionHandler('focus', this.focusHandler_);\n    this.adapter_.registerInteractionHandler('blur', this.blurHandler_);\n    this.adapter_.registerResizeHandler(this.resizeHandler_);\n    this.layout(); // At last step, provide a reasonable default value to discrete slider\n\n    if (this.isDiscrete_ && this.getStep() === 0) {\n      this.step_ = 1;\n    }\n  };\n\n  MDCSliderFoundation.prototype.destroy = function () {\n    var _this = this;\n\n    DOWN_EVENTS.forEach(function (evtName) {\n      _this.adapter_.deregisterInteractionHandler(evtName, _this.interactionStartHandler_);\n\n      _this.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this.thumbContainerPointerHandler_);\n    });\n    this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);\n    this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);\n    this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);\n    this.adapter_.deregisterResizeHandler(this.resizeHandler_);\n  };\n\n  MDCSliderFoundation.prototype.setupTrackMarker = function () {\n    if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() !== 0) {\n      this.adapter_.setTrackMarkers(this.getStep(), this.getMax(), this.getMin());\n    }\n  };\n\n  MDCSliderFoundation.prototype.layout = function () {\n    this.rect_ = this.adapter_.computeBoundingRect();\n    this.updateUIForCurrentValue_();\n  };\n\n  MDCSliderFoundation.prototype.getValue = function () {\n    return this.value_;\n  };\n\n  MDCSliderFoundation.prototype.setValue = function (value) {\n    this.setValue_(value, false);\n  };\n\n  MDCSliderFoundation.prototype.getMax = function () {\n    return this.max_;\n  };\n\n  MDCSliderFoundation.prototype.setMax = function (max) {\n    if (max < this.min_) {\n      throw new Error('Cannot set max to be less than the slider\\'s minimum value');\n    }\n\n    this.max_ = max;\n    this.setValue_(this.value_, false, true);\n    this.adapter_.setAttribute(_constants.strings.ARIA_VALUEMAX, String(this.max_));\n    this.setupTrackMarker();\n  };\n\n  MDCSliderFoundation.prototype.getMin = function () {\n    return this.min_;\n  };\n\n  MDCSliderFoundation.prototype.setMin = function (min) {\n    if (min > this.max_) {\n      throw new Error('Cannot set min to be greater than the slider\\'s maximum value');\n    }\n\n    this.min_ = min;\n    this.setValue_(this.value_, false, true);\n    this.adapter_.setAttribute(_constants.strings.ARIA_VALUEMIN, String(this.min_));\n    this.setupTrackMarker();\n  };\n\n  MDCSliderFoundation.prototype.getStep = function () {\n    return this.step_;\n  };\n\n  MDCSliderFoundation.prototype.setStep = function (step) {\n    if (step < 0) {\n      throw new Error('Step cannot be set to a negative number');\n    }\n\n    if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {\n      step = 1;\n    }\n\n    this.step_ = step;\n    this.setValue_(this.value_, false, true);\n    this.setupTrackMarker();\n  };\n\n  MDCSliderFoundation.prototype.isDisabled = function () {\n    return this.disabled_;\n  };\n\n  MDCSliderFoundation.prototype.setDisabled = function (disabled) {\n    this.disabled_ = disabled;\n    this.toggleClass_(_constants.cssClasses.DISABLED, this.disabled_);\n\n    if (this.disabled_) {\n      this.savedTabIndex_ = this.adapter_.getTabIndex();\n      this.adapter_.setAttribute(_constants.strings.ARIA_DISABLED, 'true');\n      this.adapter_.removeAttribute('tabindex');\n    } else {\n      this.adapter_.removeAttribute(_constants.strings.ARIA_DISABLED);\n\n      if (!isNaN(this.savedTabIndex_)) {\n        this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));\n      }\n    }\n  };\n  /**\n   * Called when the user starts interacting with the slider\n   */\n\n\n  MDCSliderFoundation.prototype.handleDown_ = function (downEvent) {\n    var _this = this;\n\n    if (this.disabled_) {\n      return;\n    }\n\n    this.preventFocusState_ = true;\n    this.setInTransit_(!this.handlingThumbTargetEvt_);\n    this.handlingThumbTargetEvt_ = false;\n    this.setActive_(true);\n\n    var moveHandler = function (moveEvent) {\n      _this.handleMove_(moveEvent);\n    };\n\n    var moveEventType = MOVE_EVENT_MAP[downEvent.type]; // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers\n    // do not always fire these consistently in pairs.\n    // (See https://github.com/material-components/material-components-web/issues/1192)\n\n    var upHandler = function () {\n      _this.handleUp_();\n\n      _this.adapter_.deregisterBodyInteractionHandler(moveEventType, moveHandler);\n\n      UP_EVENTS.forEach(function (evtName) {\n        return _this.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);\n      });\n    };\n\n    this.adapter_.registerBodyInteractionHandler(moveEventType, moveHandler);\n    UP_EVENTS.forEach(function (evtName) {\n      return _this.adapter_.registerBodyInteractionHandler(evtName, upHandler);\n    });\n    this.setValueFromEvt_(downEvent);\n  };\n  /**\n   * Called when the user moves the slider\n   */\n\n\n  MDCSliderFoundation.prototype.handleMove_ = function (evt) {\n    evt.preventDefault();\n    this.setValueFromEvt_(evt);\n  };\n  /**\n   * Called when the user's interaction with the slider ends\n   */\n\n\n  MDCSliderFoundation.prototype.handleUp_ = function () {\n    this.setActive_(false);\n    this.adapter_.notifyChange();\n  };\n  /**\n   * Returns the pageX of the event\n   */\n\n\n  MDCSliderFoundation.prototype.getPageX_ = function (evt) {\n    if (evt.targetTouches && evt.targetTouches.length > 0) {\n      return evt.targetTouches[0].pageX;\n    }\n\n    return evt.pageX;\n  };\n  /**\n   * Sets the slider value from an event\n   */\n\n\n  MDCSliderFoundation.prototype.setValueFromEvt_ = function (evt) {\n    var pageX = this.getPageX_(evt);\n    var value = this.computeValueFromPageX_(pageX);\n    this.setValue_(value, true);\n  };\n  /**\n   * Computes the new value from the pageX position\n   */\n\n\n  MDCSliderFoundation.prototype.computeValueFromPageX_ = function (pageX) {\n    var _a = this,\n        max = _a.max_,\n        min = _a.min_;\n\n    var xPos = pageX - this.rect_.left;\n    var pctComplete = xPos / this.rect_.width;\n\n    if (this.adapter_.isRTL()) {\n      pctComplete = 1 - pctComplete;\n    } // Fit the percentage complete between the range [min,max]\n    // by remapping from [0, 1] to [min, min+(max-min)].\n\n\n    return min + pctComplete * (max - min);\n  };\n  /**\n   * Handles keydown events\n   */\n\n\n  MDCSliderFoundation.prototype.handleKeydown_ = function (evt) {\n    var keyId = this.getKeyId_(evt);\n    var value = this.getValueForKeyId_(keyId);\n\n    if (isNaN(value)) {\n      return;\n    } // Prevent page from scrolling due to key presses that would normally scroll the page\n\n\n    evt.preventDefault();\n    this.adapter_.addClass(_constants.cssClasses.FOCUS);\n    this.setValue_(value, true);\n    this.adapter_.notifyChange();\n  };\n  /**\n   * Returns the computed name of the event\n   */\n\n\n  MDCSliderFoundation.prototype.getKeyId_ = function (kbdEvt) {\n    if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {\n      return KEY_IDS.ARROW_LEFT;\n    }\n\n    if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {\n      return KEY_IDS.ARROW_RIGHT;\n    }\n\n    if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {\n      return KEY_IDS.ARROW_UP;\n    }\n\n    if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {\n      return KEY_IDS.ARROW_DOWN;\n    }\n\n    if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {\n      return KEY_IDS.HOME;\n    }\n\n    if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {\n      return KEY_IDS.END;\n    }\n\n    if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {\n      return KEY_IDS.PAGE_UP;\n    }\n\n    if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {\n      return KEY_IDS.PAGE_DOWN;\n    }\n\n    return '';\n  };\n  /**\n   * Computes the value given a keyboard key ID\n   */\n\n\n  MDCSliderFoundation.prototype.getValueForKeyId_ = function (keyId) {\n    var _a = this,\n        max = _a.max_,\n        min = _a.min_,\n        step = _a.step_;\n\n    var delta = step || (max - min) / 100;\n    var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);\n\n    if (valueNeedsToBeFlipped) {\n      delta = -delta;\n    }\n\n    switch (keyId) {\n      case KEY_IDS.ARROW_LEFT:\n      case KEY_IDS.ARROW_DOWN:\n        return this.value_ - delta;\n\n      case KEY_IDS.ARROW_RIGHT:\n      case KEY_IDS.ARROW_UP:\n        return this.value_ + delta;\n\n      case KEY_IDS.HOME:\n        return this.min_;\n\n      case KEY_IDS.END:\n        return this.max_;\n\n      case KEY_IDS.PAGE_UP:\n        return this.value_ + delta * _constants.numbers.PAGE_FACTOR;\n\n      case KEY_IDS.PAGE_DOWN:\n        return this.value_ - delta * _constants.numbers.PAGE_FACTOR;\n\n      default:\n        return NaN;\n    }\n  };\n\n  MDCSliderFoundation.prototype.handleFocus_ = function () {\n    if (this.preventFocusState_) {\n      return;\n    }\n\n    this.adapter_.addClass(_constants.cssClasses.FOCUS);\n  };\n\n  MDCSliderFoundation.prototype.handleBlur_ = function () {\n    this.preventFocusState_ = false;\n    this.adapter_.removeClass(_constants.cssClasses.FOCUS);\n  };\n  /**\n   * Sets the value of the slider\n   */\n\n\n  MDCSliderFoundation.prototype.setValue_ = function (value, shouldFireInput, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (value === this.value_ && !force) {\n      return;\n    }\n\n    var _a = this,\n        min = _a.min_,\n        max = _a.max_;\n\n    var valueSetToBoundary = value === min || value === max;\n\n    if (this.step_ && !valueSetToBoundary) {\n      value = this.quantize_(value);\n    }\n\n    if (value < min) {\n      value = min;\n    } else if (value > max) {\n      value = max;\n    }\n\n    this.value_ = value;\n    this.adapter_.setAttribute(_constants.strings.ARIA_VALUENOW, String(this.value_));\n    this.updateUIForCurrentValue_();\n\n    if (shouldFireInput) {\n      this.adapter_.notifyInput();\n\n      if (this.isDiscrete_) {\n        this.adapter_.setMarkerValue(value);\n      }\n    }\n  };\n  /**\n   * Calculates the quantized value\n   */\n\n\n  MDCSliderFoundation.prototype.quantize_ = function (value) {\n    var numSteps = Math.round(value / this.step_);\n    return numSteps * this.step_;\n  };\n\n  MDCSliderFoundation.prototype.updateUIForCurrentValue_ = function () {\n    var _this = this;\n\n    var _a = this,\n        max = _a.max_,\n        min = _a.min_,\n        value = _a.value_;\n\n    var pctComplete = (value - min) / (max - min);\n    var translatePx = pctComplete * this.rect_.width;\n\n    if (this.adapter_.isRTL()) {\n      translatePx = this.rect_.width - translatePx;\n    }\n\n    var transformProp = (0, _util.getCorrectPropertyName)(window, 'transform');\n    var transitionendEvtName = (0, _util.getCorrectEventName)(window, 'transitionend');\n\n    if (this.inTransit_) {\n      var onTransitionEnd_1 = function () {\n        _this.setInTransit_(false);\n\n        _this.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd_1);\n      };\n\n      this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd_1);\n    }\n\n    requestAnimationFrame(function () {\n      // NOTE(traviskaufman): It would be nice to use calc() here,\n      // but IE cannot handle calcs in transforms correctly.\n      // See: https://goo.gl/NC2itk\n      // Also note that the -50% offset is used to center the slider thumb.\n      _this.adapter_.setThumbContainerStyleProperty(transformProp, \"translateX(\" + translatePx + \"px) translateX(-50%)\");\n\n      _this.adapter_.setTrackStyleProperty(transformProp, \"scaleX(\" + pctComplete + \")\");\n    });\n  };\n  /**\n   * Toggles the active state of the slider\n   */\n\n\n  MDCSliderFoundation.prototype.setActive_ = function (active) {\n    this.active_ = active;\n    this.toggleClass_(_constants.cssClasses.ACTIVE, this.active_);\n  };\n  /**\n   * Toggles the inTransit state of the slider\n   */\n\n\n  MDCSliderFoundation.prototype.setInTransit_ = function (inTransit) {\n    this.inTransit_ = inTransit;\n    this.toggleClass_(_constants.cssClasses.IN_TRANSIT, this.inTransit_);\n  };\n  /**\n   * Conditionally adds or removes a class based on shouldBePresent\n   */\n\n\n  MDCSliderFoundation.prototype.toggleClass_ = function (className, shouldBePresent) {\n    if (shouldBePresent) {\n      this.adapter_.addClass(className);\n    } else {\n      this.adapter_.removeClass(className);\n    }\n  };\n\n  return MDCSliderFoundation;\n}(_foundation.MDCFoundation);\n\nexports.MDCSliderFoundation = MDCSliderFoundation;\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\nvar _default = MDCSliderFoundation;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"ed82c4451d94d92e989a70d066ed801d","cacheData":{"env":{}}}