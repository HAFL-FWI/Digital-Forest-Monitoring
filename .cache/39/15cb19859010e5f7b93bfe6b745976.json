{"id":"../node_modules/ol/render/canvas/PolygonBuilder.js","dependencies":[{"name":"/Users/hk/Sites/digital-forest-monitoring/package.json","includedInParent":true,"mtime":1574333047455},{"name":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/package.json","includedInParent":true,"mtime":1573122283680},{"name":"../../geom/flat/simplify.js","loc":{"line":17,"column":21},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/render/canvas/PolygonBuilder.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/geom/flat/simplify.js"},{"name":"../canvas.js","loc":{"line":18,"column":33},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/render/canvas/PolygonBuilder.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/render/canvas.js"},{"name":"./Instruction.js","loc":{"line":19,"column":114},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/render/canvas/PolygonBuilder.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/render/canvas/Instruction.js"},{"name":"./Builder.js","loc":{"line":20,"column":26},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/render/canvas/PolygonBuilder.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/render/canvas/Builder.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _simplify = require(\"../../geom/flat/simplify.js\");\n\nvar _canvas = require(\"../canvas.js\");\n\nvar _Instruction = _interopRequireWildcard(require(\"./Instruction.js\"));\n\nvar _Builder = _interopRequireDefault(require(\"./Builder.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/PolygonBuilder\n */\n\n\nvar CanvasPolygonBuilder =\n/** @class */\nfunction (_super) {\n  __extends(CanvasPolygonBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n\n\n  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n\n\n  CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle !== undefined;\n    var numEnds = ends.length;\n    this.instructions.push(_Instruction.beginPathInstruction);\n    this.hitDetectionInstructions.push(_Instruction.beginPathInstruction);\n\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [_Instruction.default.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        this.instructions.push(_Instruction.closePathInstruction);\n        this.hitDetectionInstructions.push(_Instruction.closePathInstruction);\n      }\n\n      offset = end;\n    }\n\n    if (fill) {\n      this.instructions.push(_Instruction.fillInstruction);\n      this.hitDetectionInstructions.push(_Instruction.fillInstruction);\n    }\n\n    if (stroke) {\n      this.instructions.push(_Instruction.strokeInstruction);\n      this.hitDetectionInstructions.push(_Instruction.strokeInstruction);\n    }\n\n    return offset;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [_Instruction.default.CIRCLE, myBegin];\n    this.instructions.push(_Instruction.beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(_Instruction.beginPathInstruction, circleInstruction);\n\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(_Instruction.fillInstruction);\n      this.hitDetectionInstructions.push(_Instruction.fillInstruction);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(_Instruction.strokeInstruction);\n      this.hitDetectionInstructions.push(_Instruction.strokeInstruction);\n    }\n\n    this.endGeometry(feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n\n    this.endGeometry(feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonBuilder.prototype.finish = function () {\n    this.reverseHitDetectionInstructions();\n    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n\n    var tolerance = this.tolerance;\n\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = (0, _simplify.snap)(coordinates[i], tolerance);\n      }\n    }\n\n    return _super.prototype.finish.call(this);\n  };\n  /**\n   * @private\n   */\n\n\n  CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n\n  return CanvasPolygonBuilder;\n}(_Builder.default);\n\nvar _default = CanvasPolygonBuilder;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"c58dd8a6ac64f74764c8ba652c3aa258","cacheData":{"env":{}}}