{"id":"../node_modules/ol/events/Target.js","dependencies":[{"name":"/Users/hk/Sites/digital-forest-monitoring/package.json","includedInParent":true,"mtime":1574333047455},{"name":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/package.json","includedInParent":true,"mtime":1573122283680},{"name":"../Disposable.js","loc":{"line":17,"column":23},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/events/Target.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/Disposable.js"},{"name":"../functions.js","loc":{"line":18,"column":21},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/events/Target.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/functions.js"},{"name":"./Event.js","loc":{"line":19,"column":18},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/events/Target.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/events/Event.js"},{"name":"../obj.js","loc":{"line":20,"column":22},"parent":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/events/Target.js","resolved":"/Users/hk/Sites/digital-forest-monitoring/node_modules/ol/obj.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Disposable = _interopRequireDefault(require(\"../Disposable.js\"));\n\nvar _functions = require(\"../functions.js\");\n\nvar _Event = _interopRequireDefault(require(\"./Event.js\"));\n\nvar _obj = require(\"../obj.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __extends = void 0 && (void 0).__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/events/Target\n */\n\n\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nvar Target =\n/** @class */\nfunction (_super) {\n  __extends(Target, _super);\n  /**\n   * @param {*=} opt_target Default event target for dispatched events.\n   */\n\n\n  function Target(opt_target) {\n    var _this = _super.call(this) || this;\n    /**\n     * @private\n     * @type {*}\n     */\n\n\n    _this.eventTarget_ = opt_target;\n    /**\n     * @private\n     * @type {!Object<string, number>}\n     */\n\n    _this.pendingRemovals_ = {};\n    /**\n     * @private\n     * @type {!Object<string, number>}\n     */\n\n    _this.dispatching_ = {};\n    /**\n     * @private\n     * @type {!Object<string, Array<import(\"../events.js\").ListenerFunction>>}\n     */\n\n    _this.listeners_ = {};\n    return _this;\n  }\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").ListenerFunction} listener Listener.\n   */\n\n\n  Target.prototype.addEventListener = function (type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n\n    var listeners = this.listeners_[type];\n\n    if (!listeners) {\n      listeners = [];\n      this.listeners_[type] = listeners;\n    }\n\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener);\n    }\n  };\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {{type: string,\n   *     target: (EventTargetLike|undefined),\n   *     propagationStopped: (boolean|undefined)}|\n   *     import(\"./Event.js\").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n\n\n  Target.prototype.dispatchEvent = function (event) {\n    var evt = typeof event === 'string' ? new _Event.default(event) : event;\n    var type = evt.type;\n\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n\n    var listeners = this.listeners_[type];\n    var propagate;\n\n    if (listeners) {\n      if (!(type in this.dispatching_)) {\n        this.dispatching_[type] = 0;\n        this.pendingRemovals_[type] = 0;\n      }\n\n      ++this.dispatching_[type];\n\n      for (var i = 0, ii = listeners.length; i < ii; ++i) {\n        if (listeners[i].call(this, evt) === false || evt.propagationStopped) {\n          propagate = false;\n          break;\n        }\n      }\n\n      --this.dispatching_[type];\n\n      if (this.dispatching_[type] === 0) {\n        var pendingRemovals = this.pendingRemovals_[type];\n        delete this.pendingRemovals_[type];\n\n        while (pendingRemovals--) {\n          this.removeEventListener(type, _functions.VOID);\n        }\n\n        delete this.dispatching_[type];\n      }\n\n      return propagate;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Target.prototype.disposeInternal = function () {\n    (0, _obj.clear)(this.listeners_);\n  };\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import(\"../events.js\").ListenerFunction>} Listeners.\n   */\n\n\n  Target.prototype.getListeners = function (type) {\n    return this.listeners_[type];\n  };\n  /**\n   * @param {string=} opt_type Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n\n\n  Target.prototype.hasListener = function (opt_type) {\n    return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n  };\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").ListenerFunction} listener Listener.\n   */\n\n\n  Target.prototype.removeEventListener = function (type, listener) {\n    var listeners = this.listeners_[type];\n\n    if (listeners) {\n      var index = listeners.indexOf(listener);\n\n      if (index !== -1) {\n        if (type in this.pendingRemovals_) {\n          // make listener a no-op, and remove later in #dispatchEvent()\n          listeners[index] = _functions.VOID;\n          ++this.pendingRemovals_[type];\n        } else {\n          listeners.splice(index, 1);\n\n          if (listeners.length === 0) {\n            delete this.listeners_[type];\n          }\n        }\n      }\n    }\n  };\n\n  return Target;\n}(_Disposable.default);\n\nvar _default = Target;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"dbe28a79f06a80e68462d9cd9cdef36c","cacheData":{"env":{}}}